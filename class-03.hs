import Data.Char
{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка. 
-}

{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный список целых чисел следующим образом:
  a) увеличить все его элементы в два раза;
  b) увеличить все его элементы с четными значениями в два раза;
  с) обнулить все его элементы с нечетными значениями;
  d) удалить из него элементы, большие заданного числа k;
  e) отфильтровать его, оставив в списке только отрицательные числа;
  f) удалить из него все положительные чётные числа.
-}

f11a :: Integral a => [a] -> [a]
f11a a = map (*2) a

f11b :: Integral b => [b] -> [b]
f11b a = map (\x -> if odd x then x else 2 * x) a

f11c :: Integral b => [b] -> [b]
f11c a = map (\x -> if odd x then 0 else x) a

f11d :: Ord a => [a] -> a -> [a]
f11d a k = filter (<=k) a


f11e :: (Num a, Ord a) => [a] -> [a]
f11e a = filter (<0) a

f11f :: Integral a => [a] -> [a]
f11f a = filter (\x -> if even x && x > 0 then False else True) a
{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
  b) преобразовать декартовы координаты в полярные.
-}

f12a :: (Eq a, Num a2, Num a1, Num a, Ord a2, Ord a1) => [(a1, a2)] -> a -> [(a1, a2)]
f12a a k = filter (equals) a
	where 
		equals (x1, y1) = k == point_position (x1, y1)
 		point_position (x1, y1)
			| x1 >= 0 && y1 >= 0 = 1
			| x1 < 0 && y1 >= 0 = 2
			| x1 < 0 && y1 < 0 = 3
			| x1 >= 0 && y1 < 0 = 4
			| otherwise = 0

f12b :: (Floating a, Ord a) => [(a, a)] -> [(a, a)]
f12b a = map (to_polar) a
	where
		to_polar (x, y)
			| x > 0 && y >= 0 = (radius x y, atan y / x)
			| x > 0 && y < 0 = (radius x y, atan y / x + 2 * pi)
			| x < 0 = (radius x y, atan y / x + pi)
			| x == 0 && y > 0 = (radius x y, pi / 2)
			| x == 0 && y < 0 = (radius x y, 3 * pi / 2)
			| otherwise = (radius x y, 0)
		radius x y = sqrt $ x^2 + y^2

{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.
  b) Извлечь из него подсписок слов заданной длины.
  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
-}

f13a :: [String] -> [String]
f13a s = map (map toUpper) s

f13b :: [String] -> Int -> [String]
f13b s k = filter (\s -> if length s == k then True else False) s

f13c :: [String] -> Char -> [String]
f13c s k = filter (\s -> if s /= "" && head s == k then True else False) s

{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.
 b) Список чётных чисел.
 c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
 d) Список символов английского алфавита.
 e) Список строк, представляющих n-значные двоичные числа.
-}

nats :: [Integer]
nats = iterate (\r -> r + 1) 0

listEven :: [Integer]
listEven = iterate (\r -> r + 2) 0

f2c :: [Double]
f2c = iterate (\r -> (1 + r) / 2) 1

f2d :: [Char]
f2d = take 26 $ iterate (\r -> chr $ ord r + 1) 'a'

{-
3. Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
  b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
     координаты точек, лежащие в одной координатной четверти.
  c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
     Последний подсписок может содержать менее n элементов.
  d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
     длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
-}

f3d :: [a] -> Int -> Int -> [[a]]
f3d xs n m = undefined

-- Должно быть True
test_f3d = f3d [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

{-
4. Разные задачи.
 a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
    всех упоминающихся в тексте чисел.
 b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
    (например: все чётные от 1 до 106).
 c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
    в строке символов.
 d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
    называется элемент, больший своих соседей.
 e) Дан список. Продублировать все его элементы.
-}
